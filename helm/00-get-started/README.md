# Basic Helm Chart

The Helm chart `superapi` was created with `helm create superapi`. That command creates a Helm chart with the following files in the superapi folder:
- Chart.yaml
- values.yaml
- templates/ (the folder that contains the templates for the chart)
- templates/deployment.yaml
- templates/service.yaml
- templates/ingress.yaml
- ...

The `helm create` command uses a default starter template, which deploys nginx. You can uses other starter templates by specifying the `--starter` flag. To make working with starter templates easier, there is a Helm 3 plugin called `helm-starter`. See https://github.com/salesforce/helm-starter for more information.

The chart you created can already be deployed to a Kubernetes cluster with the following command, from the folder that contains superapi:

```bash
helm install superapi
```

Instead of installing the chart, you can do a dry run with the `--dry-run` flag:

```bash
helm install superapi --dry-run
```

Or just get the YAML output with the helm template command:

```bash
helm template superapi
```

## Chart.yaml

The contents of Chart.yaml has been modified from the one generated by the `helm create` command. It lists the required fields, followed by the optional fields:

```yaml
# required keys
apiVersion: v2
name: superapi
version: 0.1.0

# default type is application (vs library)
type: application

# optional fields of the chart
description: A Helm chart for Kubernetes
appVersion: "1.16.0" # used as image tag if image tag is not specified
keywords:
    - api
    - golang
home: https://github.com/gbaeke/super-api
sources: https://github.com/gbaeke/super-api
icon: https://raw.githubusercontent.com/gbaeke/super-api/master/icon.png #png or svg
maintainers:
  - name: Geert Baeke
    email: me@example.com
```

With Helm 3, always set `apiVersion` to v2. Note that the chart has a version that should use semantic versioning. When you make changes to your chart, you are supposed to update the version of the chart. The version of the application can be stored in `appVersion`. This could refer to the version of nginx. In the starter chart, the version of the application is set to `1.16.0` and will be used as the image tag if no image tag is specified. See `deployment.yaml` in the templates folder for more information.

## values.yaml

Helm works with values that you can use in your templates. The values.yaml file contains the default values for your chart. During installation or upgrade, you can specify your own values for the chart, with one or more values files. In addition, you can override specific values with the `--set` flag.

Let's look at an example in the values.yaml used by the starter template. The first few lines are shown below:

```yaml
# Default values for superapi.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

replicaCount: 1

image:
  repository: nginx
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""
```

Above, the `replicaCount` variable is set to 1. The `image` variable is a map that contains the repository, pullPolicy, and tag. The `tag` variable is set to an empty string. The `image` variable is used in the `deployment.yaml` template.

To refer to the `replicaCount`, we can use {{ .Values.replicaCount }}. To refer to the `image.repository`, we can use {{ .Values.image.repository }}.

In the deployment template, the values are referred to as follows (snippet from the deployment template):

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "superapi.fullname" . }}
  labels:
    {{- include "superapi.labels" . | nindent 4 }}
spec:
  {{- if not .Values.autoscaling.enabled }}
  replicas: {{ .Values.replicaCount }}
  {{- end }}
```

The template looks like a regular Kubernetes YAML manifest but with templates to set the values. The `replicas` field is set to the value of the `replicaCount` variable in the values.yaml file with {{ .Values.replicaCount }}.

## Dot object (.)

Note the . in front of Values. When you run helm, it passes an object to the template that contains a lot of data. Values is part of that object. The "dot" object contains other data as well:
- .Chart: the values in Chart.yaml such as .Chart.Name and .Chart.Version
- .Release: values such as .Release.Name and .Release.Namespace
- .Capabilities: Kubernetes capabilities
- .Files: the files in the chart and methods to access files

In deployment.yaml, there are references to .Chart. For instance in this snippet in the pod template:

```yaml
containers:
        - name: {{ .Chart.Name }}
          securityContext:
            {{- toYaml .Values.securityContext | nindent 12 }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
```

Above, `image` is set with two templates. The second template uses a `pipeline`. Pipelines in Helm are similar to Unix/Linux pipelines and use | as a separator. The pipeline does the following:
- retrieve the tag of the image from .Values.image.tag
- when .Values.image.tag is not set, use .Chart.AppVersion; this is done with the `default` function and it uses the AppVersion defined in Chart.yaml as the default value

## Reusable templates in _helpers.tpl

You can define templates that you can use in other templates. The _helpers.tpl file contains these reusable templates. Let's take one of the templates in _helpers.tpl:

```yaml
{{/*
Common labels
*/}}
{{- define "superapi.labels" -}}
helm.sh/chart: {{ include "superapi.chart" . }}
{{ include "superapi.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}
```

Above, a template `superapi.labels` is defined. It defines labels such as `helm.sh/chart` and others and uses other templates to set their values. As you can see, you define a reusable template with `define`. You call other templates with `include`. Note that {{ .Release.Service }} will be Helm.

This template is used in deployment.yaml. The following snippet shows how to use it:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "superapi.fullname" . }}
  labels:
    {{- include "superapi.labels" . | nindent 4 }}
```

Above, the labels are set by calling the `superapi.labels` template via the `include` function. The `nindent` function is used to indent the output of the template.

What happens when we do not use the `nindent` function? The `helm template` command will not complain and just produce this output:

```yaml
# Source: superapi/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: RELEASE-NAME-superapi
  labels:helm.sh/chart: superapi-0.1.0
app.kubernetes.io/name: superapi
app.kubernetes.io/instance: RELEASE-NAME
app.kubernetes.io/version: "1.16.0"
app.kubernetes.io/managed-by: Helm
```

However, when you run `helm install myapp superapi --dry-run` you will get the following error:

```
Error: unable to build kubernetes objects from release manifest: error validating "": error validating data: [ValidationError(Deployment): unknown field "app.kubernetes.io/instance" in io.k8s.api.apps.v1.Deployment, ValidationError(Deployment): unknown field "app.kubernetes.io/managed-by" in io.k8s.api.apps.v1.Deployment, ValidationError(Deployment): unknown field "app.kubernetes.io/name" in io.k8s.api.apps.v1.Deployment, ValidationError(Deployment): unknown field "app.kubernetes.io/version" in io.k8s.api.apps.v1.Deployment, ValidationError(Deployment.metadata): unknown field "labels:helm.sh/chart" in io.k8s.apimachinery.pkg.apis.meta.v1.ObjectMeta]
```

⚠️ Although you can define resuable templates anywhere, you should create reusable templates in _helpers.tpl.